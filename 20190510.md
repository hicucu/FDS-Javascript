# 생성자 함수에 의한 객체 생성

객체는 객체 리터럴 표기법 이외에도 다양한 방법으로 생성할 수 있음

## Object 생성자 함수

new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환
빈 객체를 생성한 후 프로퍼티 또는 메소드를 추가하여 객체를 완성

생성자(Constructor) 함수 : new 연산자와 함께 호출하여 객체를 생성하는 함수

인스턴스(instance) : 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어, 생성자 함수도 객체이기 때문에 생성자 함수나 클래스가 생성한 객체를 다른 객체와 구분하기 위해 사용

Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인 생성자 함수 제공

## 생성자 함수

### 객체 리터럴에 의한 객체 생성 방식의 문제점

객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편
객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성
동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 할는 경우, 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적

객체는 프로퍼티를 통해 객체 고유의 상태(state)를 표현
메소드를 통해 상태 데이터인 프로포티를 참조하고 조작하는 동작을 표현
-> 프포퍼티 값이 다를 수 있지만 메소드는 내용이 동일한 경우가 일반적

객체 리터럴에 의해 객체를 생성하는 경우 프포퍼티 구조가 동일함에도 매번 같은 프로퍼티와 메소드를 기술해야 함 -> 수십개의 객체를 생성하는 경우 문제가 큼

### 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수에 의해 객체 생성 방식은 매치 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프포퍼티 구조가 동일한 객체 여러개를 간편하게 생성 가능

this

- 일반 함수로서 호출 : 전역 객체
- 메소드로서 호출 : 메소드를 호출한 객체
- 생성자 함수로서 호출 : 생성자 함수가 생성할 인스턴스

생성자 함수는 이름 그대로 객체를 생성하는 함수
일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작

### 내부 메소드[[Call]]과 [[Constructor]]

생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미

함수는 객체이므로 일반 객체와 동일하게 동작 가능
즉 함수 객체는 일반 객체의 내부 슬롯과 내부 메소드를 모두 가짐

내부 메소드 [[Call]]이 구현되어 있는 객체를 callable이라 하며, 내부 메소드인 [[Constructor]]이 구현되어 있는 객체를 constructor, [[Constructor]]가 구현되어 있지 않은 객체를 non-constructor라 부름

callable은 호출할 수 있는 객체, 즉 함수
constructor는 생성자 함수로서 호출할 수 있는 객체 = new 연산자와 함께 호출하는 것을 의미

함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Constructor]]가 호출

호츨할 수 없는 객체는 함수 객체가 아니므로 함수로서 기능하는 객체, 즉 함수 객체는 반드시 callable
모든 함수 객체는 [[Call]]이 구현되어 있어 호출 가능
하지만 모든 함수 객체가 [[Constructor]]를 구현하지는 않음
-> 함수객체는 constructor일 수도 있고 non-constructor일 수 있음

모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아님

### constructor와 non-constructor의 구분

자바스크립트 엔진은 함수를 생성할 때, FunctionCreate이라는 추상 연산을 사용
추상 연산 : ECMAScript 사양에서 내부 동작의 구현 알고리즘을 표현한 것, ECMAScript 사양에서 설명을 위해 사용되는 함수와 유사한 의사 코드

추상 연산 FunctionCreate는 함수 정의가 평가될 때 호출
-> 함수 정의 방식에 따라 FunctionCreate의 첫번째 매개변수 kind에 함수의 종류를 나타내는 문자열이 전달

일반 함수 정의(함수 선언문, 함수 표현식)를 평가할 때 : Normal
화살표 함수 정의를 평가할 때 : Arrow
메소드 정의를 평가할 때 : Method

ECMAScript 사양에서 “메소드 정의”로 인정하는 범위가 일반적인 메소드보다 좁다는 것
일반적으로 프로퍼티의 값인 함수는 모두 메소드로 통칭
하지만 ECMAScript 사양에서 “메소드 정의”란 ES6의 메소드 축약 표현만을 의미한다. 다시 말해 함수가 어디에 할당되어 있는지에 따라 메소드 정의인지를 판단하는 것이 아니라 함수 정의 방식에 따라 함수의 종류를 구분

일반 함수로 정의된 함수만이 constructor, 함수의 종류가 Arrow, Method인 함수는 non-constructor
같이 일반 함수로 정의된 함수만이 생성자 함수로서 호출 가능

non-constructor인 함수 객체는 내부 메소드 [[Constructor]]가 구현되어 있지 않음
non-constructor인 함수 객체를 생성자 함수로서 호출하면 에러가 발생
생성자 함수로서 호출될 것을 기대하고 정의하지 않은 일반 함수(callable이면서 constructor)에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것
-> 생성자 함수는 일반적으로 첫문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력

### 2.5. 생성자 함수의 동작 방식

생성자 함수의 역활은 프로퍼티 구조와 동일한 인스턴스를 생성하기 위한 템플릿으로 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스의 프로퍼티 값을 초기화하는 것
생성자 함수가 인스턴스를 생성하는 것은 필수이고, 생성된 인스턴스의 프로퍼티 값을 초기화하는 것은 옵션

자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환
new 연산자와 함께 생성자 함수가 호출되면 자바스크립트 엔진은 아래와 같은 과정을 거쳐 인스턴스를 생성하고 프로퍼티를 초기화한 후, 인스턴스를 반환

함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손
-> 생성자 함수 내부에서 return 문을 반드시 생략

### 2.6. new 연산자

new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작
new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이여야 함

### new.target

new 연산자 없이 생성자 함수를 호출하는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생
-> 이러한 위험성을 회피하기 위해 ES6에서는 new.target을 지원

함수가 new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리킴. new 연산자 없이 호출된 함수 내부의 new.target은 undefined

# 함수와 일급 객체

## 일급 객체

- 무명의 리터럴로 생성가능. 즉, 런타임에 생성이 가능
- 변수나 자료 구조(객체, 배열 등)에 저장 가능
- 함수의 매개변수에게 전달 가능
- 함수의 반환값으로 사용 가능

## 함수 객체의 프로퍼티

함수는 객체 -> 프포퍼티를 가질 수 있음

### arguments 프로퍼티

함수 객체의 arguments 프로퍼티 값은 arguments 객체
arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object)이며 함수 내부에서 지역 변수처럼 사용됨
함수 외부에서는 사용할 수 없음
함수 객체의 arguments 프로퍼티는 현재 일부 브라우저에서 지원하고 있지만 ES3부터 표준에서 폐지(deprecated)
모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관

### caller 프로퍼티

caller 프로퍼티는 ECMAScript 스펙에 포함되지 않은 비표준 프로퍼티
표준화될 예정도 없는 프로퍼티

### length 프로퍼티

함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수
arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있음
arguments 객체의 length 프로퍼티는 인자의 개수를 가리키고, 함수 객체의 length 프로퍼티는 매개변수의 개수

### name 프로퍼티

함수 객체의 name 프로퍼티는 함수명
ES6 이전에는 비표준이었고 ES6에서 정식 표준
ES5와 ES6에서 동작을 달리

ES5에서 name 프로퍼티는 빈 문자열
ES6에서는 함수 객체를 가리키는 변수명

### \_\_proto\_\_ 접근자 프로퍼티

모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖음
[[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체

\_\_proto\_\_ 프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티

내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근가능
[[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 \_\_proto\_\_ 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근 가능

### prototype 프로퍼티

함수 객체만이 소유하는 프로퍼티
일반 객체에는 prototype 프로퍼티가 없음
prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킴
