# 엄격모드

## strict mode란?

자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시하던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적 에러를 발생시킴

## strict mode의 적용

strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두에 `'use strict';`를 추가
전역의 선두에 추가하면 스크립트 전체에 적용

함수 몸체의 선두에 추가하면 해당 함수와 중첩된 내부 함수에 적용

코드의 선두에 위치시키지 않으면 제대로 동작하지 않음

## 전역에 strict mode를 적용하는 것은 피하자.

전역에 적용하면 스크립트 단위로 적용
스크립트 단위로 적용된 strict mode는 다른 스크립트에 영향을 주지 않고 자신의 스크립트에 한정 적용

strict mode 스크립트와 non-strict mode 스크립트를 혼용하는 것은 오류 발생 가능

외부 서드 파티 라이브러리를 사용하는 경우 라이브러리가 non-strict mode일 경우 전역에 strict mode를 적용하는 것은 바람직하지 않음
이런 경우 즉시 실행 함수로 스크립트 전체를 감싸 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode 적용

## 함수 단위로 strict mode를 적용하는 것도 피하자.

어떤 함수는 strict mode를 적용하고 어떤 함수는 strict mode를 적용하지 않는 것은 바람직하지 않으며 모든 함수에 일일이 strict mode를 적용하는 것은 번거로움
-> strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 바람직

## strict mode가 발생시키는 에러

- 암묵적 전역변수
- 변수, 함수, 매개변수의 삭제
- 매개변수 이름의 중복
- with 문의 사용
- 일반 함수의 this

# 전역 객체

클라이언트 사이드 : window
서버 사이드 : global

전역 객체는 개발자가 의도적으로 생성 불가 -> [[Constructor]] 내부 메소드를 가지고 있지 않아 new 연산자와 함께 생성자 함수를 호출하여 생성 불가

전역 객체의 프로퍼티를 참조할 때 전역객체 생략가능

Object, string, Number, Boolean, Function, Array, RegExp, Date, Math, Promise와 같은 모든 빌트인 객체를 프로퍼티로 가지고 있음

자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메소드를 갖음 -> 브라우저 환경의 window 객체는 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker와 같은 클라이언트 사이드 Web API를 프로퍼티로 소유

var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 변수 그리고 전역 함수는 전역 객체의 프로퍼티가 됨

## 전역 프로퍼티(Global property)

전역 객체의 프로퍼티를 의미
애플리케이션 전역에서 사용하는 값들을 나타내기 위해 사용

### Infinity

양/음의 무한대를 나타내는 숫자값

### NaN

NaN 프로퍼티는 숫자가 아님을 나타내는 숫자값을 소유
= Number.NaN 프로퍼티와 같음

### undefined

undefined 프로퍼티는 원시 타입 undefined를 값으로 소유

## 전역 함수(Global function)

애플리케이션 전역에서 호출할 수 있는 함수로서 전역 객체의 메소드

### eval

매개변수에 전달된 코드(표현식 또는 문)을 나타내는 문자열을 평가 또는 실행하고 결과값을 반환
전달된 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 일괄 실행

자바스크립트는 렉시컬 스코프를 따르므로 스코프는 함수 정의가 평가되는 시점에서 결정
하지만 eval 함수는 런타임에 스코프를 수정할 수 있음 -> 렉시컬 스코프를 동적으로 수정 가능, 성능적인 면에서 손해 발생

엄격모든에서 eval함수는 기존의 스코프를 수정하지 않고 자신만의 독자적인 스코프를 생성

eval 함수에 전달한 변수 선언문이 let, const 키워드를 사용했다면 엄격모드가 적용됨

eval 함수를 통해 사용자로부터 입력 받은 콘텐츠(untrusted data)를 실행하는 것은 보안에 매우 취약
바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드 실행에 비해 처리 속도가 느림

### isFinite

매개변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환
숫자로 타입을 변환한 후 검사를 수행

### isNaN

매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리런 타입으로 반환
매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행

### parseFloat

매개변수에 전달된 문자열을 부동소수점 숫자(floating point number)로 변환하여 반환

### parseInt

매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환
반환값은 언제나 10진수
주어진 변환 대상 값이 문자열이 아니면 문자열로 변환한 후 정수형 숫자로 해석하여 반환

2번째 매개변수에는 진법을 나타내는 기수(2 ~ 36) 지정 가능
기수를 지정하면 첫번째 매개변수에 전달된 문자열을 해당 기수의 숫자로 해석하여 반환
반환값은 언제나 10진수
기수를 생략하면 첫번째 매개변수에 전달된 문자열을 10진수로 해석하여 반환

### encodeURI / decodeURI

encodeURI 함수는 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩
인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미
이스케이프 처리는 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋(ASCII Character-set)으로로 변환하는 것
decodeURI 함수는 매개변수로 전달된 인코딩된 URI을 전달받아 이스케이프 처리되기 이전으로 디코딩

### encodeURIComponent / decodeURIComponent

encodeURIComponent 함수은 매개변수로 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩
인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미
알파벳, 0~9의 숫자, - \_ . ! ~ \* ‘ ( ) 문자는 이스케이프 처리에서 제외

encodeURIComponent 함수는 매개변수로 전달된 문자열을 URI의 구성요소인 쿼리 파라미터의 일부 간주 -> 쿼리 파라미터 구분자로 사용되는 =, ?, &를 인코딩
반면 encodeURI 함수는 매개변수로 전달된 문자열을 완전한 URI 전체라고 간주한다. 따라서 쿼리 파라미터 구분자로 사용되는 =, ?, &를 인코딩하지 않음

# this

this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)
함수를 호출하면 arguments객체와 this가 암묵적으로 함수 내부에 전달
함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있음

this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정

바인딩 - 식별자와 값을 연결하는 과정, 변수는 할당에 의해 값이 바인딩됨

## 함수 호출 방식과 this 바인딩

this에 바인딩될 객체는 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정

### 일반 함수 호출

기본적으로 this에는 전역 객체가 바인딩
일반 함수로 호출된 함수 내부의 this에는 전역 객체가 바인딩됨
메소드의 중첩 함수, 콜백 함수 내부의 this에도 전역 객체가 바인딩

일반 함수로 호출된 모든 함수, 중첩 함수, 콜백 함수 내부의 this에는 전역 객체가 바인딩됨
this를 명시적으로 바인딩할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메소드를 제공

### 메소드 호출

메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞의 마침표(.)연산자 앞에 기술한 객체에 바인딩

메소드 내부의 this는 메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩

프로토타입 메소드 내부에서 사용된 this도 일반 메소드와 마찬가지로 해당 메소드를 호출한 객체에 바인딩

### 생성자 함수 호출

생성자 함수 내부의 this는 생성자 함수가 (미래에) 생성할 인스턴스를 바인딩

생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수
일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작
만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작

### Function.prototype.apply/call/bind 메소드에 의한 간접 호출

Function.prototype.apply, Function.prototype.call 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출
apply와 call 메소드는 Function.prototype의 메소드
apply와 call 메소드는 Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 상속받아 사용할 수 있음

apply와 call 메소드는 본질적은 기능은 함수를 호출하는 것
apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 this에 명시적으로 바인딩

apply와 call 메소드는 차이는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작

bind 메소드는 메소드의 this와 메소드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용

콜백 함수를 호출하는 외부 함수 내부의 this와 콜백 함수 내부의 this가 상이하기 때문에 문맥상 문제가 발생 -> 콜백 함수 내부의 this를 콜백 함수를 호출하는 함수 내부의 this와 일치시켜야 함
이때 bind 메소드를 사용하여 this를 일치시킬 수 있음

일반 함수 호출 : 전역 객체
메소드 호출 : 메소드를 호출한 객체
생성자 함수 호출 : 생성자 함수가 (미래에) 생성할 인스턴스
Function.prototype.apply/call/bind 메소드에 의한 간접 호출 : Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체
