# 전역 변수의 문제점

## 변수의 생명 주기

### 지역 변수의 생명 주기

변수는 생성되고 소멸되는 생명 주기(Life cycle)가 존재
변수는 자신이 선언된 위치에서 생성되고 소멸
전역 변수의 생명 주기는 애플리케이션의 생명주기와 동일
하지만 함수 내부에서 선언된 지역 변 수는 함수가 호출되면 생성되고 함수가 종료되면 소멸

함수 내부의 변수 선언은 함수가 호출된 직후 함수 몸체의 다른 코드가 실행되기 전에 먼저 실행

지역 변수의 생명 주기 = 함수의 생명 주기

변수 호이스팅은 스코프 단위로 동작

### 전역 변수의 생명 주기

전역 코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행

함수는 함수 몸체에 return 문이 실행되면 종료, 하지만 전역 코드는 마지막 문이 실행되어 더 이상 실행할 문이 없어도 함수처럼 종료되지 않음

node.js는 가장 바깥 영역에 return 사용시 에러가 없으나 브라우저는 에러 발생

전역 변수의 생명 주기 = 애플리케이션의 생명 주기

## 전역 변수의 문제점

`암묵적 결함`
모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결함(implicit coupling)을 허용, 유효 범위가 클수록 가독성은 떨어지고 의도치 않게 상태가 변경될 위험은 증가

`긴 생명 주기`
전역 변수는 생명 주기가 김
var 키워드는 변수의 중복 선언을 허용하여 생명 주기가 긴 전역 변수는 변수명이 중복되어 재할됭 될 가능성이 큼

`스코프 체인 상에서 종점에 존재`
전역 변수의 검색 속도가 가장 느림

`네임 스페이스 오염`
파일이 분리되어도 하나의 전역 스코프를 공유
동일한 이름의 변수나 함수가 존재할 경우 예상치 못한 결과 발생 가능

## 전역 변수 사용 억제 방법

전역 변수를 반드시 사용할 이유를 찾지 못한다면 지역 변수를 사용
변수의 스코프는 좁을 수록 좋음

### 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨
-> 전역 변수를 생성하지 않음, 라이브러리 등에서 자주 사용

### 네임 스페이스 객체

전역에 네임 스페이스 역활을 담당할 객체를 생성, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로터티로 추가하여 네임 스페이스를 계층적으로 구성

### 모듈 패턴

관련이 있는 변수와 함수를 몯아 즉시 실행 함수로 감싸 하나의 모듈 구성
클로저 기반
전역 변수의 억제와 캡슐화까지 구현가능

캡슐화는 외부에 공개될 필요가 없는 정보를 외부에 노출시키지 않고 숨기는 것 - 정보은닉

# let, const와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점

ES5까지 변수를 선언할 수 있는 유일한 벙법은 var 키워드

### 변수 중복 선언 허용

var 키워드로 선언한 변수는 중복 선언 가능
나중에 선언된 변수는 var 키워드가 없는 것 처럼 동작
에러가 발생하지 않음 -> 중복 선언을 모르고 사용할 경우 값이 변경되는 부작용 발생

### 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정 -> 외부에서 선언한 변수는 모두 전역 변수

### 변수 호이스팅

var 키워드로 변수 선언시 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 올려진 것 처럼 동작

변수 선언문 이전에 변수를 참조하는 것이 에러를 발생시키지 않지만 프로그램의 흐름 상 맞지 않고 가독성을 떨어트려 오류 발생 가능성을 만듬

## let 키워드

### 변수 중복 선언 금지

let키워드로 동일한 이름을 갖는 변수를 중복 선언하면 문법 에러 발생

### 블록 레벨 스코프

let 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따름
함수 내 코드 블록은 함수 레벨 스코프에 중첩

### 변수 호이스팅

let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작

let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러 발생

let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행
런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행

일시적 사각지대(Temporal Dead Zone; TDZ)스코프 시작 지점부터 초기화 시작 지점까지의 구간

let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않은 것처럼 보임 -> 자바스크립트는 모든 선언을 호이스팅 함

### 전역 객체와 let

전역 객체 : 모든 객체의 유일한 최상위 객체

- 브라우저 : window 객체
- Node.js : global 객체

전역 함수는 전역 객체의 프로퍼티 -> window 생략 가능

let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아님
let 전역 변수는 보이지 않는 개념적인 블록내에 존재

## const 키워드

const 키워드는 상수를 선언하기 위해 사용
반드시 상수만을 위해 사용하는 것은 아님

### 선언과 초기화

const : 재할당 금지 -> 상수를 변수에 할당하기 위해 사용

const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 함 -> 아니면 오류 발생

블록 레벨 스코프

### 상수

가독성과 유지보수의 편의를 위해 적극적 사용 필요

상수는 프로그램 전체에서 공통 사용하므로 유지보수성이 대폭 향상

### const 키워드와 객체

const 키워드로 선언한 변수에 객체를 할당한 경우 재할당이 금지
-> 객체는 mutable
const 키워드로 선언된 변수에 할당된 객체는 변경이 가능

const 키워드는 재할당을 금지, 불변을 의미하지는 않음

새로운 객체를 재할당하는 것은 불가능하지만 객체의 내용을 변경하는 것은 가능
-> 객체의 내용이 변경되더라도 변수에 할당된 주소값은 변경되지 않음

## var vs let vs const

ES6에서는 var 키워드를 사용하지 않음
재할당이 필요하면 let
변경이 발생하지 않는 원기 값과 객체는 const -> 재할당이 불가하여 보다 안전

# 프로퍼티 정의

## 프로퍼티 정의란?

프로퍼티 어트리부트의 값을 정의하여 프로퍼티의 상태를 관리하는 것

자바스크립트 엔진은 프로퍼티를 생성(객체 리터럴의 평가, 프로퍼티 동적 생성)할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 정의

프로퍼티에 값을 할당하는 코드는 프로퍼티가 없을 경우, 프로퍼티를 생성하여 추가하는 부수 효과를 갖음
프로퍼티의 유무를 먼저 확인하여 존재하는 프로퍼티에 값을 할당할 것인지, 프로퍼티를 동적으로 생성한 후 값을 할당할 것인지를 결정

프로퍼티 동적 생성은 프로퍼티가 존재하지 않을 때, 프로퍼티를 생성하여 추가하는 것
프로퍼티 정의는 프로퍼티 어트리뷰트를 정의하는 것

프로퍼티 어트리뷰트는 프로퍼티의 상태
= <b>프로퍼티의 값, 값의 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부</b>를 의미

프로퍼티 어트리뷰트는 Object.getOwnPropertyDescriptor 메소드를 사용하여 참조
-> 자신의 프로퍼티 어트리뷰트를 객체로 표현한 프로퍼티 디스크럽터 객체를 반환

존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined가 반환
인수는 객체의 참조와 데이터 프로퍼티의 키를 문자열로 전달

프로퍼티가 동적 생성될 때 자바스크립트 엔진은 프로퍼티 어트리뷰트를 기본값으로 정의, 재정의 가능

## 내부 슬롯/메소드

내부 슬롯(Internal slot)과 내부 메소드(Internal method)는 ECMAScript 스펙에서 요구하는 객체와 관련된 내부 상태와 내부 동작을 정의
재부 슬롯과 내부 메소드는 자바스크립트 엔진이 코드를 실행하는 알고리즘을 설명하기 위해 ECMAScript 스펙에서 사용하는 의사 프로퍼티(Pseude property)와 의사 메소드(Pseudo method)

ECMAScript 스펙에 등장하는 이중 대괄호([[…]])로 감싼 이름들이 내부 슬롯과 내부 메소드

## 접근자 프로퍼티

데이터 프로퍼티(Data property)
: 키와 값으로 구성된 일반적인 프로퍼티
접근자 프로퍼티(Accessor property)
: 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티 -> getter / setter

접근자 프로퍼티와 데이터 프로퍼티의 프로퍼티 디스크립터의 객체 프로퍼티는 다름
데이터 프로퍼티

- 값
- 변경 가능 여부
- 열거 가능 여부
- 재정의 가능 여부

접근자 프로퍼티

- get
- set
- 열거 가능 여부
- 재정의 가능 여부

# 오타

13. 전역 변수의 문제점 - 3.2. 네임 스페이스 객체

> 네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼터로 추가하여 네임 스페이스를 계층적으로 구성할 수도 있다.

프로퍼터로 되어 있습니다.

15. 프로퍼티 정의 - 1. 프로퍼티 정의란
    하단

> 프로터티가 동적 생성될 때 자바스크립트 엔진은 프로퍼티 어트리뷰트를 기본값으로 정의한다. 이미 정의된 프로퍼티 어트리뷰트를 재정의하는 것도 가능하다.

프로터티로 되어있습니다.
